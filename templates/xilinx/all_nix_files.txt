# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2024 Jiuyang Liu <liu@jiuyang.me>

# This is a bit dirty.
# Since VCS are close source toolchains, we have no way to fix it for environment changes.
# So here we have to lock the whole nixpkgs to a working version.
#
# For convenience, we still use the nixpkgs defined in flake to "callPackage" this derivation.
# But the buildFHSEnv, targetPkgs is still from the locked nixpkgs.
{ getEnv', fetchFromGitHub }:
let
  nixpkgsSrcs = fetchFromGitHub {
    owner = "NixOS";
    repo = "nixpkgs";
    rev = "c374d94f1536013ca8e92341b540eba4c22f9c62";
    hash = "sha256-Z/ELQhrSd7bMzTO8r7NZgi9g5emh+aRKoCdaAv5fiO0=";
  };

  # The vcs we have only support x86-64_linux
  lockedPkgs = import nixpkgsSrcs { system = "x86_64-linux"; };

  vcStaticHome = getEnv' "VC_STATIC_HOME";
  lmLicenseFile = getEnv' "LM_LICENSE_FILE";
in
lockedPkgs.buildFHSEnv {
  name = "vcs-fhs-env";
  profile = ''
    [ ! -e "${vcStaticHome}"  ] && echo "env VC_STATIC_HOME='${vcStaticHome}' points to unknown location" && exit 1
    [ ! -d "${vcStaticHome}"  ] && echo "VC_STATIC_HOME='${vcStaticHome}' not accessible" && exit 1
    export VC_STATIC_HOME=${vcStaticHome}

    export TCL_TZ=UTC
    export VC_STATIC_HOME=$VC_STATIC_HOME
    export VCS_HOME=$VC_STATIC_HOME/vcs/U-2023.03-SP2
    export VCS_TARGET_ARCH=amd64
    export VCS_ARCH_OVERRIDE=linux
    export VERDI_HOME=$VC_STATIC_HOME/verdi/V-2023.12-SP2
    export NOVAS_HOME=$VC_STATIC_HOME/verdi/V-2023.12-SP2
    export SNPS_VERDI_CBUG_LCA=1
    export LM_LICENSE_FILE=${lmLicenseFile}

    export PATH=$PATH:$VCS_HOME/gui/dve/bin:$PATH
    export PATH=$PATH:$VCS_HOME/bin:$PATH
    export PATH=$PATH:$VERDI_HOME/bin:$PATH
    export PATH=$PATH:$SCL_HOME/linux64/bin:$PATH

    export QT_X11_NO_MITSHM=1
    export LD_LIBRARY_PATH=/usr/lib64/
    export LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/lib/LINUX64:$LD_LIBRARY_PATH
    export LD_LIBRARY_PATH=$VERDI_HOME/share/NPI/lib/LINUX64:$LD_LIBRARY_PATH

    export _oldVcsEnvPath="$PATH"
    preHook() {
      PATH="$PATH:$_oldVcsEnvPath"
    }
    export -f preHook
  '';
  targetPkgs = (
    ps: with ps; [
      libGL
      util-linux
      libxcrypt-legacy
      coreutils-full
      ncurses5
      gmp5
      bzip2
      glib
      bc
      time
      elfutils
      ncurses5
      e2fsprogs
      cyrus_sasl
      expat
      sqlite
      nssmdns
      (libkrb5.overrideAttrs rec {
        version = "1.18.2";
        src = fetchurl {
          url = "https://kerberos.org/dist/krb5/${lib.versions.majorMinor version}/krb5-${version}.tar.gz";
          hash = "sha256-xuTJ7BqYFBw/XWbd8aE1VJBQyfq06aRiDumyIIWHOuA=";
        };
        sourceRoot = "krb5-${version}/src";
      })
      (gnugrep.overrideAttrs rec {
        version = "3.1";
        doCheck = false;
        src = fetchurl {
          url = "mirror://gnu/grep/grep-${version}.tar.xz";
          hash = "sha256-22JcerO7PudXs5JqXPqNnhw5ka0kcHqD3eil7yv3oH4=";
        };
      })
      keyutils
      graphite2
      libpulseaudio
      libxml2
      gcc
      gnumake
      xorg.libX11
      xorg.libXft
      xorg.libXScrnSaver
      xorg.libXext
      xorg.libxcb
      xorg.libXau
      xorg.libXrender
      xorg.libXcomposite
      xorg.libXi
      zlib

      # Synopsys debug tools dependencies
      gdb
      strace 

      # verdi other dependencies
      dejavu_fonts
      freetype
      fontconfig
      xorg.libXcursor
      xorg.libXinerama
      xorg.libXtst
      xorg.libXt    
      xorg.libXmu    
      xorg.libXpm     
      xorg.libXaw
      xorg.libSM               
      xorg.libICE          
      xorg.libXrandr       
      numactl
      libpng
      libjpeg
      expat
    ]
  );
}

{ getEnv', fetchFromGitHub }:
let
  nixpkgsSrcs = fetchFromGitHub {
    owner = "NixOS";
    repo = "nixpkgs";
    rev = "c374d94f1536013ca8e92341b540eba4c22f9c62";
    hash = "sha256-Z/ELQhrSd7bMzTO8r7NZgi9g5emh+aRKoCdaAv5fiO0=";
  };

  lockedPkgs = import nixpkgsSrcs {
    system = "x86_64-linux";
    config.allowUnfree = true;
  };

  xilinxHome = getEnv' "XILINX_STATIC_HOME"; 
  
in
lockedPkgs.buildFHSEnv {
  name = "xilinx-vitis-fhs-env";

  profile = ''
    export LC_NUMERIC="en_US.UTF-8"

    if [ -n "${xilinxHome}" ] && [ -d "${xilinxHome}" ]; then
      source ${xilinxHome}/Vitis_HLS/*/settings64.sh
    elif [ -d "$HOME/Xilinx/Vitis_HLS" ]; then
      source ~/Xilinx/Vitis_HLS/*/settings64.sh
    fi
    
    echo "Xilinx FHS Environment Loaded."
    echo "Check 'vitis' or 'vivado' command."
  '';

  targetPkgs = (ps: with ps; 
    let
      # 修复 ncurses5 以提供 libtinfo.so.5，并包含 termlib 支持
      ncurses' = ncurses5.overrideAttrs (old: {
        configureFlags = old.configureFlags ++ [ "--with-termlib" ];
        postFixup = "";
      });
    in 
    [
      bash
      coreutils
      zlib
      lsb-release
      stdenv.cc.cc

      # https://github.com/NixOS/nixpkgs/issues/218534
      # postFixup would create symlinks for the non-unicode version but since it breaks
      # in buildFHSEnv, we just install both variants
      ncurses'
      (ncurses'.override { unicodeSupport = false; })
      xorg.libXext
      xorg.libX11
      xorg.libXrender
      xorg.libXtst
      xorg.libXi
      xorg.libXft
      xorg.libxcb
      xorg.libxcb
      # common requirements
      freetype
      fontconfig
      glib
      gtk2
      gtk3
      libxcrypt-legacy # required for Vivado
      python3

      (libidn.overrideAttrs (_old: {
        # we need libidn.so.11 but nixpkgs has libidn.so.12
        src = fetchurl {
          url = "mirror://gnu/libidn/libidn-1.34.tar.gz";
          sha256 = "sha256-Nxnil18vsoYF3zR5w4CvLPSrTpGeFQZSfkx2cK//bjw=";
        };
      }))

      # to compile some xilinx examples
      opencl-clhpp
      ocl-icd
      opencl-headers

      # from installLibs.sh
      graphviz
      (lib.hiPrio gcc)
      unzip
      nettools
    ]
  );
}
{
  lib,
  stdenvNoCC,
  target, 
}:
let
  fs = lib.fileset;
  
  rtlFiles = fs.fileFilter (file: 
    lib.hasSuffix ".v" file.name || lib.hasSuffix ".sv" file.name
  ) ./../../demo/src;

in
stdenvNoCC.mkDerivation {
  name = "${target}-rtl";

  src = fs.toSource {
    root = ./../../demo;
    fileset = rtlFiles;
  };

  # 纯文件处理逻辑
  dontBuild = true;

  passthru = {
    inherit target;
  };

  installPhase = ''
    runHook preInstall

    mkdir -p $out

    cp -r ./* $out/

    pushd $out
    find . -type f \( -name "*.v" -o -name "*.sv" \) > ./filelist.f
    popd

    runHook postInstall
  '';
}
{
  lib,
  stdenv,
  verilator,
  zlib,
  python3,
  rtl,
  enableTrace ? false,
  thread-num ? 8,
}:

let
  vName = "V${rtl.target}";
in
stdenv.mkDerivation {
  pname = "demo-verilated-sim";
  version = "0.1.0";

  src = ./../../demo; 
  nativeBuildInputs = [ verilator python3 ];

  propagateBuildInputs = lib.optionals enableTrace [ zlib ];

  passthru = {
    inherit (rtl) target;
  };

  meta.mainProgram = vName;

  buildPhase = ''
    runHook preBuild

    echo "[nix] running verilator"
    
    verilator \
      ${lib.optionalString enableTrace "--trace"} \
      --timing \
      --threads ${toString thread-num} \
      -O1 \
      --exe ./testbench/sim_main.cpp \
      --cc -f ${rtl}/filelist.f \
      --top ${rtl.target} \
      --Mdir obj_dir \
      -Wall

    echo "[nix] building verilated simulator"

    mkdir -p $out/share
    cp -r obj_dir $out/share/verilated_src

    cd obj_dir
    make -j "$NIX_BUILD_CORES" -f ${vName}.mk ${vName}

    runHook postBuild
  '';
  
  installPhase = ''
    runHook preInstall

    mkdir -p $out/{include,lib,bin}
    cp *.h $out/include
    cp *.a $out/lib
    cp ${vName} $out/bin

    runHook postInstall
  '';

  hardeningDisable = [ "fortify" ];

}
{ lib, newScope }:
lib.makeScope newScope (
  scope:
  let
    designTarget = "demo";
  in
  {
    # RTL
    rtl = scope.callPackage ./rtl.nix { target = designTarget; };

    # Verilator
    verilated = scope.callPackage ./verilated.nix { 
      enableTrace = false; 
    };
    verilated-trace = scope.verilated.override { enableTrace = true; };

    # VCS
    vcs = scope.callPackage ./vcs.nix { 
      enableTrace = false; 
    };
    vcs-trace = scope.vcs.override { enableTrace = true; };

    # Verdi
    verdi = scope.callPackage ./verdi.nix { };
  }
)
{
  lib,
  stdenv,
  bash,
  vcs-fhs-env,
}:

stdenv.mkDerivation {
  name = "verdi-wrapper";

  unpackPhase = "true";

  installPhase = ''
    mkdir -p $out/bin

    substitute ${./scripts/verdi-wrapper.sh} $out/bin/verdi-view \
      --subst-var-by shell "${bash}/bin/bash" \
      --subst-var-by vcsFhsEnv "${vcs-fhs-env}/bin/vcs-fhs-env"

    chmod +x $out/bin/verdi-view
  '';

  meta.mainProgram = "verdi-view";
}
{
  lib,
  bash,
  stdenv,
  rtl,
  vcs-fhs-env,
  runCommand,
  enableTrace ? false,
  enableCover ? true,
}:
let 
  binName = "demo-vcs-simulator";
  coverageName = "coverage.vdb";
in
stdenv.mkDerivation (finalAttr: {
  name = "vcs";

  __noChroot = true;
  dontPatchELF = true;

  src = rtl;

  meta.mainProgram = binName;

  buildPhase = ''
    runHook preBuild

    export HOME=$TMPDIR 

    echo "[nix] running VCS"
    fhsBash=${vcs-fhs-env}/bin/vcs-fhs-env
    echo "[nix] Checking environment inside FHS..."
    "$fhsBash" -c "ls -d $VC_STATIC_HOME" || (echo "Error: VC_STATIC_HOME not accessible"; exit 1)

    VERDI_HOME=$("$fhsBash" -c "printenv VERDI_HOME")

    "$fhsBash" vcs \
      -sverilog \
      -full64 \
      -timescale=1ns/1ps \
      -P $VERDI_HOME/share/PLI/VCS/LINUX64/novas.tab $VERDI_HOME/share/PLI/VCS/LINUX64/pli.a \
    ${lib.optionalString enableTrace ''
      -debug_access+pp+dmptf+thread \
      -kdb=common_elab,hgldd_all \
      -assert enable_diag ''} \
    ${lib.optionalString enableCover ''
      -cm line+cond+fsm+tgl+branch+assert \
      -cm_dir ${coverageName} ''} \
      -top tb_demo \
      -file filelist.f \
      -o ${binName}

    runHook postBuild
  '';

  passthru = {
    inherit vcs-fhs-env;
    inherit rtl;
    inherit enableTrace;

    tests.simple-sim = runCommand "${binName}-test" { __noChroot = true; }''
      export DEMO_SIM_RESULT_DIR="$(mktemp -d)"
      export DATA_ONLY=1
      ${finalAttr.finalPackage}/bin/${binName}

      mkdir -p "$out"
      cp -vr "$DEMO_SIM_RESULT_DIR"/result/* "$out/"
    '';
  };


  shellHook = ''
    echo "[nix] entering vcd fhs env"
    ${vcs-fhs-env}/bin/vcs-fhs-env
  '';

  installPhase = ''
    runHook preInstall

    mkdir -p $out/bin $out/lib
    cp ${binName} $out/lib
    cp -r ${binName}.daidir $out/lib

    ${lib.optionalString enableCover ''cp -r ${coverageName} $out/lib''}

    substitute ${./scripts/vcs-wrapper.sh} $out/bin/${binName} \
      --subst-var-by lib "$out/lib" \
      --subst-var-by shell "${bash}/bin/bash" \
      --subst-var-by dateBin "$(command -v date)" \
      --subst-var-by vcsSimBin "$out/lib/${binName}" \
      --subst-var-by vcsSimDaidir "$out/lib/${binName}.daidir" \
      --subst-var-by vcsCovDir "${lib.optionalString enableCover "${coverageName}"}" \
      --subst-var-by vcsFhsEnv "${vcs-fhs-env}/bin/vcs-fhs-env"
    
    chmod +x $out/bin/${binName}

    runHook postInstall
  '';
})
let 
  getEnv' = 
    key:
    let 
      val = builtins.getEnv key;
    in
    if val == "" then builtins.throw " ${key} not set or 'impure' not appiled" else val;
in
final: prev: {
  vcs-fhs-env = final.callPackage ./pkgs/vcs-fhs-env.nix { inherit getEnv';};
  # xilinx-fhs-env = final.callPackage ./pkgs/xilinx-fhs-env.nix { inherit getEnv';};
  demo = final.callPackage ./demo { };

}
{
  description = "Xilinx Nix";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    flake-parts = {
      url = "github:hercules-ci/flake-parts";
      inputs.nixpkgs-lib.follows = "nixpkgs";
    };
    treefmt-nix = {
      url = "github:numtide/treefmt-nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };
  
  outputs = 
    inputs@{
      self, 
      nixpkgs,
      flake-parts,
      ...
    }:
    let 
      overlay = import ./nix/overlay.nix;
    in
    flake-parts.lib.mkFlake { inherit inputs; } {
        systems = [ 
          "x86_64-linux" 
          "aarch64-linux"
          "aarch64-darwin"
        ];
        
        imports = [
          inputs.treefmt-nix.flakeModule
        ];

        flake.overlays.default = overlay;
        perSystem = 
        { system, pkgs, ... }:
        {
          _module.args.pkgs = import nixpkgs {
              inherit system;
              overlays = [ overlay ];
              config.allowUnfree = true; 
          };

          legacyPackages = pkgs;

          treefmt = {
            projectRootFile = "flake.nix";
            programs.nixfmt.enable = true;
            programs.verible-verilog-format.enable = true;
          };

          devShells.default = pkgs.mkShell {
            inputsFrom = [ 
              pkgs.demo.verilated 
              pkgs.demo.vcs 
            ];

            packages = with pkgs; [
              # 开发辅助
              nixd
              verible
              gtkwave  
              # xilinx-fhs-env
            ];

            shellHook = ''
              echo "--- RTL Development Shell ---"
              echo "Available Simulators:"
              echo "  - VDemo (Verilator)"
              echo "  - demo-vcs-simulator (VCS, needs --impure)"
              echo ""
              echo "Available FHS Envs:"
              echo "  - vcs-fhs-env"
              echo "  - xilinx-fhs-env"
            '';
          };
        };
    };
}

